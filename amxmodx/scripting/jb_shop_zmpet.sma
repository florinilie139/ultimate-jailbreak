/* Plugin generated by AMXX-Studio */

#include <amxmodx>
#include <fakemeta>
#include <hamsandwich>
#include <xs>

#define PLUGIN "[JB] Zombie Pet"
#define VERSION "1.0"
#define AUTHOR "Natsheh"

#define ZOMBIE_PET_ENTITY "info_target"
#define PEV_IDENTITY pev_iuser4
#define PEV_TASK pev_iuser3
#define PEV_ARRAY_PATH pev_iuser2
#define PEV_ANIM_TASK pev_iuser1
#define ZOMBIE_PET_ID 85471

new iITEM_ID, ZOMBIE_PET_MODEL[32] = "zombie_pet";

enum ZOMBIE_PET_TASKS (+=1)
{
	IDLE = 0,
	FOLLOW_OWNER,
	MOVE_AROUND,
	PROTECT,
	DEATH,
	KILLSELF
}

enum _:ANIM_TASKS (+=1)
{
	ANIM_IDLE, ANIM_CROUCHIDLE, ANIM_CROUCHRUN, ANIM_WALK, ANIM_RUN, ANIM_ATTACK1, ANIM_ATTACK2, ANIM_JUMP, ANIM_DEATH
}


new Array:anim_idle, Array:anim_crouchrun,
		Array:anim_walk, Array:anim_run, Array:anim_crouchidle, Array:anim_jump, Array:anim_attack1, Array:anim_attack2, Array:anim_death;

new Iidle, Icrouchidle, Icrouchrun, Iwalk, Irun, Ijump, Iattack1, Iattack2, Ideath;

new Float:fMAX_SIZE[3];
new Float:fMIN_SIZE[3];

public plugin_end()
{
	ArrayDestroy(anim_idle);
	ArrayDestroy(anim_walk);
	ArrayDestroy(anim_run);
	ArrayDestroy(anim_crouchrun);
	ArrayDestroy(anim_crouchidle);
	ArrayDestroy(anim_jump);
	ArrayDestroy(anim_attack1);
	ArrayDestroy(anim_attack2);
	ArrayDestroy(anim_death);
}

public plugin_precache()
{
	anim_idle = ArrayCreate(1,1);
	anim_walk = ArrayCreate(1,1);
	anim_run = ArrayCreate(1,1);
	anim_crouchrun = ArrayCreate(1,1);
	anim_crouchidle = ArrayCreate(1,1);
	anim_jump = ArrayCreate(1,1);
	anim_attack1 = ArrayCreate(1,1);
	anim_attack2 = ArrayCreate(1,1);
	anim_death = ArrayCreate(1,1);
	
	jb_ini_get_keyvalue("ZOMBIE_PET", "ZOMBIE_PET_MDL", ZOMBIE_PET_MODEL, charsmax(ZOMBIE_PET_MODEL));
	
	new szString[64];
	formatex(szString, charsmax(szString), "models/player/%s/%s.mdl", ZOMBIE_PET_MODEL, ZOMBIE_PET_MODEL);
	precache_model(szString);
	
	//mdlsize(szString, fMAX_SIZE, fMIN_SIZE);
	fMAX_SIZE[0] = 16.0
	fMAX_SIZE[1] = 16.0
	fMAX_SIZE[2] = 72.0;
	
	fMIN_SIZE[0] = -16.0;
	fMIN_SIZE[1] = -16.0;
	fMIN_SIZE[2] = -0.0;
	
	new szSequence[32], i;
	
	while( getSequenceName(szString, i++, szSequence, charsmax(szSequence)) )
	{
		if(containi(szSequence, "IDLE") != -1)
		{
			ArrayPushCell(anim_idle, i-1);
		}
		else if(containi(szSequence, "WALK") != -1)
		{
			ArrayPushCell(anim_walk, i-1);
		}
		else if(containi(szSequence, "RUN") != -1)
		{
			ArrayPushCell(anim_run, i-1);
		}
		else if(containi(szSequence, "CROUCH") != -1 && containi(szSequence, "RUN") != -1)
		{
			ArrayPushCell(anim_crouchrun, i-1);
		}
		else if(containi(szSequence, "CROUCH") != -1)
		{
			ArrayPushCell(anim_crouchidle, i-1);
		}
		else if(containi(szSequence, "JUMP") != -1)
		{
			ArrayPushCell(anim_jump, i-1);
		}
		else if(containi(szSequence, "ATTACK1") != -1)
		{
			ArrayPushCell(anim_attack1, i-1);
		}
		else if(containi(szSequence, "ATTACK2") != -1)
		{
			ArrayPushCell(anim_attack2, i-1);
		}
		else if(containi(szSequence, "DEATH") != -1 || containi(szSequence, "DIE") != -1)
		{
			ArrayPushCell(anim_death, i-1);
		}
	}
	
	Iidle = ArraySize(anim_idle);
	Iwalk = ArraySize(anim_walk);
	Irun = ArraySize(anim_run);
	Icrouchrun = ArraySize(anim_crouchrun);
	Icrouchidle = ArraySize(anim_crouchidle);
	Ijump = ArraySize(anim_jump);
	Iattack1 = ArraySize(anim_attack1);
	Iattack2 = ArraySize(anim_attack2);
	
	formatex(szString, charsmax(szString), "models/player/%s/%sT.mdl", ZOMBIE_PET_MODEL, ZOMBIE_PET_MODEL);
	if(file_exists(szString)) precache_model(szString);
}

public plugin_init()
{
	register_plugin(PLUGIN, VERSION, AUTHOR)
	
	iITEM_ID = register_jailbreak_shopitem("Zombie Pet", "He takes care of you", 25000, TEAM_PRISONERS); 
	register_forward(FM_Think, "zombie_brain", 1);
	RegisterHam(Ham_Killed, ZOMBIE_PET_ENTITY, "zombie_pet_killed_post", 1);
	RegisterHam(Ham_TakeDamage, ZOMBIE_PET_ENTITY, "zombie_pet_takedmg_post", 1);
}

public jb_shop_item_bought(id, itemid)
{
	if(itemid == iITEM_ID)
	{
		spawn_zombie_pet(id)
	}
}

enum NPC_DATA (+=1)
{
	Float:fORIGIN[3] = 0,
	Sequence,
	bool:bCrouching
}

spawn_zombie_pet(owner)
{
	new ent = engfunc(EngFunc_CreateNamedEntity, engfunc(EngFunc_AllocString, ZOMBIE_PET_ENTITY));
	
	if(!ent) return 0;
	
	new szString[64], Float:fOrigin[3];
	formatex(szString, charsmax(szString), "models/player/%s/%s.mdl", ZOMBIE_PET_MODEL, ZOMBIE_PET_MODEL);
	engfunc(EngFunc_SetModel, ent, szString);
	engfunc(EngFunc_SetSize, ent, fMIN_SIZE, fMAX_SIZE);
	set_pev(ent, pev_health, 500.0);
	set_pev(ent, pev_takedamage, DAMAGE_AIM);
	set_pev(ent, pev_solid, SOLID_BBOX);
	set_pev(ent, pev_movetype, MOVETYPE_PUSHSTEP);
	set_pev(ent, pev_gravity, 0.8);
	set_pev(ent, PEV_IDENTITY, ZOMBIE_PET_ID);
	set_pev(ent, PEV_ARRAY_PATH, _:ArrayCreate(_:NPC_DATA));
	set_pev(ent, PEV_TASK, IDLE);
	set_pev(ent, pev_owner, owner);
	set_pev(ent, pev_controller_0, 125);
	set_pev(ent, pev_friction, 4);
	
	set_pev(ent, pev_flags, FL_MONSTER|FL_ALWAYSTHINK|FL_BASEVELOCITY);
	
	pev(owner, pev_origin, fOrigin);
	fOrigin[2] += 5.0;
	engfunc(EngFunc_SetOrigin, ent, fOrigin);
	
	engfunc(EngFunc_DropToFloor, ent);
	
	set_pev(ent, pev_nextthink, get_gametime() + 0.1);
	
	return 1;
}

public zombie_pet_takedmg_post(id, inflictor, attacker, Float:damage, damagebits)
{
	if(!pev_valid(id)) return HAM_IGNORED;
	if(pev(id, PEV_IDENTITY) != ZOMBIE_PET_ID) return HAM_IGNORED;
	
	if(pev(id, pev_owner) == attacker) return HAM_IGNORED;
	
	set_pev(id, pev_euser1, attacker);
	set_pev(id, PEV_TASK, PROTECT);
	
	return HAM_IGNORED;
}

public zombie_pet_killed_post(id)
{
	if(!pev_valid(id)) return HAM_IGNORED;
	if(pev(id, PEV_IDENTITY) != ZOMBIE_PET_ID) return HAM_IGNORED;
	
	new Array:gArray = Array:pev(id, PEV_ARRAY_PATH);
	ArrayDestroy(gArray);
	client_print(pev(id, pev_owner), print_chat, "your zombie pet has died, sadly!");
	
	set_pev(id, PEV_TASK, DEATH)
	return HAM_IGNORED;
}

public zombie_brain(id)
{
	if(!pev_valid(id)) return;
	
	if(pev(id, PEV_IDENTITY) != ZOMBIE_PET_ID) return;
	
	static Float:fGtime, iOwner, Float:fVelocity[3];
	fGtime = get_gametime();
	iOwner = pev(id, pev_owner);
	pev(id, pev_velocity, fVelocity);
	
	switch( pev(id, PEV_TASK) )
	{
		case DEATH:
		{
			fVelocity[0] = 0.0; fVelocity[1] = 0.0;
			set_pev(id, pev_velocity, fVelocity);
			if(Ideath > 0) PlayAnimation(id, ArrayGetCell(anim_death, random(Ideath)), _, ANIM_DEATH);
			set_pev(id, PEV_TASK, KILLSELF);
			set_pev(id, pev_nextthink, fGtime + 5.0);
		}
		case IDLE:
		{
			fVelocity[0] = 0.0; fVelocity[1] = 0.0;
			set_pev(id, pev_velocity, fVelocity);
			if(Iidle > 0) PlayAnimation(id, ArrayGetCell(anim_idle, random(Iidle)), _, ANIM_IDLE);
			set_pev(id, PEV_TASK, FOLLOW_OWNER);
			
			set_pev(id, pev_nextthink, fGtime + 0.5);
		}
		case PROTECT:
		{
			static iVictim, Float:fLen; iVictim = pev(id, pev_euser1);
			fLen = 0.1;
			
			if(pev_valid(iVictim) && pev(iVictim, pev_health) > 0)
			{
				static Float:fOriginDest[3], Float:fDelay, Float:fOrigin[3];
				pev(iVictim, pev_origin, fOriginDest);
				pev(id, pev_origin, fOrigin);
				
				if(!fDelay) fDelay = -1.0;
				
				LookAtOrigin(id, fOriginDest);
				
				switch( floatround(get_distance_f(fOriginDest, fOrigin)) )
				{
					case 0..100:
					{
						if(fDelay == -1.0)
						{
							fDelay = fGtime + 1.2;
							if(Iattack1 > 0) PlayAnimation(id, ArrayGetCell(anim_attack1, random(Iattack1)), _, -1);
						}
						
						if(fDelay < fGtime)
						{
							static Float:fPunch[3];
							fPunch[0] = random_float(-45.0, 45.0);
							fPunch[1] = random_float(-90.0, 90.0);
							set_pev(iVictim, pev_punchangle, fPunch);
							ExecuteHamB(Ham_TakeDamage, iVictim, id, id, 50.0, DMG_SLASH);
							fDelay = -1.0;
						}
						
						fVelocity[0] = 0.0; fVelocity[1] = 0.0;
						set_pev(id, pev_velocity, fVelocity);
					}
					default:
					{
						MoveToOrigin(id, fOriginDest, 320.0);
						
						static iFlags;
						
						if((iFlags = pev(id, pev_flags)) & FL_ONGROUND)
						{
							static iVelo;
							iVelo = floatround(xs_vec_len(fVelocity));
							if(!(iFlags & FL_DUCKING))
							{
								switch(iVelo)
								{
									case 0: if(Iidle > 0) PlayAnimation(id, ArrayGetCell(anim_idle, random(Iidle)), _, ANIM_IDLE);
									case 1..100: if(Iwalk > 0) PlayAnimation(id, ArrayGetCell(anim_walk, random(Iwalk)), _, ANIM_WALK);
									default: if(Irun > 0) PlayAnimation(id, ArrayGetCell(anim_run, random(Irun)), _, ANIM_RUN);
								}
							}
							else
							{
								switch(iVelo)
								{
									case 0: if(Icrouchidle > 0) PlayAnimation(id, ArrayGetCell(anim_crouchidle, random(Icrouchidle)), _, ANIM_CROUCHIDLE);
									default: if(Icrouchrun > 0) PlayAnimation(id, ArrayGetCell(anim_crouchrun, random(Icrouchrun)), _, ANIM_CROUCHRUN);
								}
							}
						}
						else
						{
							if(Ijump > 0) PlayAnimation(id, ArrayGetCell(anim_jump, random(Ijump)), _, ANIM_JUMP);
						}
						
						fDelay = -1.0;
					}
				}
			}
			else
			{
				set_pev(id, pev_euser1, 0);
				set_pev(id, PEV_TASK, FOLLOW_OWNER);
			}
			
			set_pev(id, pev_nextthink, fGtime + fLen);
		}
		case FOLLOW_OWNER:
		{
			static Float:fOrigin[3], Float:fOriginDest[3], Array:g_iArray, Float:fLength;
			fLength = fGtime + 0.01;
			pev(id, pev_origin, fOrigin);
			pev(iOwner, pev_origin, fOriginDest);
			g_iArray = Array:pev(id, PEV_ARRAY_PATH);
			
			static ArraySize_, iFlags;
			ArraySize_ = ArraySize(g_iArray);
			
			if((iFlags = pev(id, pev_flags)) & FL_ONGROUND)
			{
				static iVelo;
				iVelo = floatround(xs_vec_len(fVelocity));
				if(!(iFlags & FL_DUCKING))
				{
					switch(iVelo)
					{
						case 0: if(!ArraySize_ && Iidle > 0) PlayAnimation(id, ArrayGetCell(anim_idle, random(Iidle)), _, ANIM_IDLE);
						case 1..100: if(ArraySize_ <= 1 && Iwalk > 0) PlayAnimation(id, ArrayGetCell(anim_walk, random(Iwalk)), _, ANIM_WALK);
						default: if(Irun > 0) PlayAnimation(id, ArrayGetCell(anim_run, random(Irun)), _, ANIM_RUN);
					}
				}
				else
				{
					switch(iVelo)
					{
						case 0: if(Icrouchidle > 0) PlayAnimation(id, ArrayGetCell(anim_crouchidle, random(Icrouchidle)), _, ANIM_CROUCHIDLE);
						default: if(Icrouchrun > 0) PlayAnimation(id, ArrayGetCell(anim_crouchrun, random(Icrouchrun)), _, ANIM_CROUCHRUN);
					}
				}
			}
			else
			{
				if(Ijump > 0) PlayAnimation(id, ArrayGetCell(anim_jump, random(Ijump)), _, ANIM_JUMP);
			}
			
			if(!NearOwner(iOwner,id,150.0))
			{
				static any:iData[NPC_DATA], Float:fDelay, Float:fTemp[3];
				xs_vec_copy(fOriginDest, iData[fORIGIN]);
				xs_vec_copy(fOrigin, fTemp);
				iData[Sequence] = pev(iOwner, pev_sequence);
				iData[bCrouching] = (pev(iOwner, pev_flags) & FL_DUCKING) ? true:false;
				
				if(ArraySize_ > 0)
				{
					ArrayGetArray(g_iArray, ArraySize_-1, any:iData);
					xs_vec_copy(iData[fORIGIN], fTemp);
					xs_vec_copy(fOriginDest, iData[fORIGIN]);
					iData[Sequence] = pev(iOwner, pev_sequence);
					iData[bCrouching] = (pev(iOwner, pev_flags) & FL_DUCKING) ? true:false;
				}
				
				if(get_distance_f(fTemp, fOriginDest) >= 100.0 && !ObjectStuck(fTemp, fMAX_SIZE, fMIN_SIZE))
				{
					ArrayPushArray(g_iArray, any:iData);
				}
				
				if(fDelay < fGtime && ArraySize_ > 0)
				{
					static Float:fMaxs[3];
					ArrayGetArray(g_iArray, 0, any:iData);
					xs_vec_copy(iData[fORIGIN], fTemp);
					xs_vec_copy(fMAX_SIZE, fMaxs);
					
					switch(iData[bCrouching])
					{
						case true:
						{
							if(!(iFlags & FL_DUCKING))
							{
								fMaxs[2] *= 0.5;
								set_pev(id, pev_bInDuck, true);
								set_pev(id, pev_flags, (iFlags|FL_DUCKING));
								engfunc(EngFunc_SetSize, id, fMIN_SIZE, fMaxs);
							}
						}
						default: 
						{
							if(iFlags & FL_DUCKING)
							{
								fOrigin[2] += (fMaxs[2] * 0.5);
								set_pev(id, pev_origin, fOrigin)
								set_pev(id, pev_bInDuck, false);
								set_pev(id, pev_flags, (iFlags & ~FL_DUCKING))
								engfunc(EngFunc_SetSize, id, fMIN_SIZE, fMaxs);
							}
						}
					}
					
					ArrayDeleteItem(g_iArray, 0); // removing 1st item
					fDelay = fGtime + MoveToOrigin(id, fTemp, 320.0);
					LookAtOrigin(id, fTemp);
				}
			}
			else
			{
				LookAtOrigin(id, fOriginDest);
				if(ArraySize_ > 0) ArrayClear(g_iArray);
			}
			
			set_pev(id, pev_nextthink, fLength);
		}
		case KILLSELF:
		{
			set_pev(id, pev_flags, FL_KILLME);
			return;
		}
	}
	
	if(is_user_alive(iOwner))
	{
		static attacker;
		if((attacker=get_user_attacker(iOwner)) > 0 && attacker != iOwner)
		{
			set_pev(id, pev_euser1, attacker);
			set_pev(id, PEV_TASK, PROTECT);
		}
	}
}

stock NearOwner(iOwner, iPet, Float:fDistance=300.0)
{
	static Float:fOrigin[3], Float:fOrigin2[3];
	pev(iOwner, pev_origin, fOrigin);
	pev(iPet, pev_origin, fOrigin2);
	
	return (get_distance_f(fOrigin, fOrigin2) <= fDistance) ? true:false;
}

stock LookAtOrigin(const id, const Float:fOrigin_dest[3])
{
	static Float:fOrigin[3];
	pev(id, pev_origin, fOrigin);
	
	static Float:fLook[3];
	xs_vec_sub(fOrigin_dest, fOrigin, fOrigin);
	xs_vec_normalize(fOrigin, fOrigin);
	vector_to_angle(fOrigin, fLook);
	fLook[0] = 0.0;
	
	set_pev(id, pev_angles, fLook);
	set_pev(id, pev_fixangle, 1);
}

stock Float:MoveToOrigin(const id, const Float:fOrigin_dest[3], Float:fSpeed=250.0)
{
	if(fSpeed <= 0.0) fSpeed = 1.0;
	
	static Float:fOrigin[3];
	pev(id, pev_origin, fOrigin);
	
	static Float:fDistance;
	fDistance = get_distance_f(fOrigin, fOrigin_dest);
	
	if(fDistance <= 0.0) fDistance = 0.1;
	
	static Float:fVelocity[3], Float:fDiff[3];
	xs_vec_sub(fOrigin_dest, fOrigin, fDiff);
	
	fVelocity[0] = (fDiff[0] / fDistance) * fSpeed;
	fVelocity[1] = (fDiff[1] / fDistance) * fSpeed;
	
	if(!(50.0 >= fDiff[2] >= -50.0))
	{
		fVelocity[2] = (fDiff[2] / fDistance) * fSpeed;
	}
	
	set_pev(id, pev_velocity, fVelocity);
	
	return floatdiv(fDistance,floatsqroot((floatpower(fVelocity[0],2.0) + floatpower(fVelocity[1],2.0) + floatpower(fVelocity[2],2.0))) + 0.001);
}

stock PlayAnimation(const id, const iSeq=0, const Float:fFrameRate=1.0, const ANIM_TYPE=ANIM_IDLE)
{
	if(pev(id, PEV_ANIM_TASK) != ANIM_TYPE || ANIM_TYPE == -1)
	{
		set_pev(id, pev_animtime, get_gametime());
		set_pev(id, pev_frame, 0.0);
		set_pev(id, pev_framerate, fFrameRate);
		set_pev(id, pev_sequence, iSeq);
		set_pev(id, PEV_ANIM_TASK, ANIM_TYPE);
	}
}

stock getSequenceName( const model[], const sequence, sequenceName[], nameLen = sizeof sequenceName )
{
	static sequencesNameCached;
	static sequenceCount;
	static Array:arraySequencesName;
	
	if( !sequencesNameCached )
	{
		new f = fopen( model, "rb" );
		
		if( f )
		{
		const studioHeader_NumSeq = 164;
		const mstudioseqdescSize  = 176;
		const sequenceNameLength  = 32;
		
		new sequenceIndex;
		
		fseek( f, studioHeader_NumSeq, SEEK_SET );
		{
			fread( f, sequenceCount, BLOCK_INT );
			fread( f, sequenceIndex, BLOCK_INT );
		}
		fseek( f, sequenceIndex, SEEK_SET );
		
		arraySequencesName = ArrayCreate( sequenceNameLength, sequenceCount );
		
		for( new i = 0; i < sequenceCount; i++ )
		{
			fread_blocks( f, sequenceName, sequenceNameLength, BLOCK_CHAR );
			fseek( f, mstudioseqdescSize - sequenceNameLength, SEEK_CUR );
			
			ArrayPushString( arraySequencesName, sequenceName );
		}
	
		fclose( f );
		
		if( !( sequencesNameCached = !!ArraySize( arraySequencesName ) ) )
		{
			ArrayDestroy( arraySequencesName );
			return 0;
		}
		}
	}
	
	if( sequencesNameCached && 0 <= sequence < sequenceCount )
	{
		return formatex( sequenceName, nameLen, "%a", ArrayGetStringHandle( arraySequencesName, sequence ) );
	}	
    
	return 0;
}

stock bool:ObjectStuck(const Float:fOrigin[3], const Float:fMaxs[3], const Float:fMins[3])
{
	static Float:fPoint[3];
	xs_vec_add(fOrigin, fMaxs, fPoint);
	if(engfunc(EngFunc_PointContents, fPoint) != CONTENTS_EMPTY) return true;
	
	xs_vec_add(fOrigin, fMins, fPoint);
	if(engfunc(EngFunc_PointContents, fPoint) != CONTENTS_EMPTY) return true;
	
	fPoint[0] = fOrigin[0] + fMaxs[0];
	fPoint[1] = fOrigin[1] + fMaxs[1];
	fPoint[2] = fOrigin[2] + fMins[2];
	if(engfunc(EngFunc_PointContents, fPoint) != CONTENTS_EMPTY) return true;
	
	fPoint[0] = fOrigin[0] + fMaxs[0];
	fPoint[1] = fOrigin[1] + fMins[1];
	fPoint[2] = fOrigin[2] + fMins[2];
	if(engfunc(EngFunc_PointContents, fPoint) != CONTENTS_EMPTY) return true;
	
	fPoint[0] = fOrigin[0] + fMaxs[0];
	fPoint[1] = fOrigin[1] + fMins[1];
	fPoint[2] = fOrigin[2] + fMaxs[2];
	if(engfunc(EngFunc_PointContents, fPoint) != CONTENTS_EMPTY) return true;
	
	fPoint[0] = fOrigin[0] + fMins[0];
	fPoint[1] = fOrigin[1] + fMins[1];
	fPoint[2] = fOrigin[2] + fMaxs[2];
	if(engfunc(EngFunc_PointContents, fPoint) != CONTENTS_EMPTY) return true;
	
	fPoint[0] = fOrigin[0] + fMins[0];
	fPoint[1] = fOrigin[1] + fMaxs[1];
	fPoint[2] = fOrigin[2] + fMins[2];
	if(engfunc(EngFunc_PointContents, fPoint) != CONTENTS_EMPTY) return true;
	
	fPoint[0] = fOrigin[0] + fMins[0];
	fPoint[1] = fOrigin[1] + fMaxs[1];
	fPoint[2] = fOrigin[2] + fMaxs[2];
	if(engfunc(EngFunc_PointContents, fPoint) != CONTENTS_EMPTY) return true;
	
	fPoint[0] = fOrigin[0] + fMaxs[0];
	fPoint[1] = fOrigin[1];
	fPoint[2] = fOrigin[2];
	if(engfunc(EngFunc_PointContents, fPoint) != CONTENTS_EMPTY) return true;
	
	fPoint[0] = fOrigin[0];
	fPoint[1] = fOrigin[1] + fMaxs[1];
	fPoint[2] = fOrigin[2];
	if(engfunc(EngFunc_PointContents, fPoint) != CONTENTS_EMPTY) return true;
	
	fPoint[0] = fOrigin[0];
	fPoint[1] = fOrigin[1];
	fPoint[2] = fOrigin[2] + fMaxs[2];
	if(engfunc(EngFunc_PointContents, fPoint) != CONTENTS_EMPTY) return true;
	
	fPoint[0] = fOrigin[0] + fMins[0];
	fPoint[1] = fOrigin[1];
	fPoint[2] = fOrigin[2];
	if(engfunc(EngFunc_PointContents, fPoint) != CONTENTS_EMPTY) return true;
	
	fPoint[0] = fOrigin[0];
	fPoint[1] = fOrigin[1] + fMins[1];
	fPoint[2] = fOrigin[2];
	if(engfunc(EngFunc_PointContents, fPoint) != CONTENTS_EMPTY) return true;
	
	fPoint[0] = fOrigin[0];
	fPoint[1] = fOrigin[1];
	fPoint[2] = fOrigin[2] + fMins[2];
	if(engfunc(EngFunc_PointContents, fPoint) != CONTENTS_EMPTY) return true;
	
	return false;
}

/* Thanks to backup
stock mdlsize(filename[],Float:fMaxs[3],Float:fMins[3]){
	new file = fopen(filename,"rb")
	fseek(file,160,SEEK_SET)
	new bboff
	fread(file,bboff,BLOCK_INT)
	fseek(file,bboff+8,SEEK_SET)
	new Float:size[6]
	fread_blocks(file,_:size,6,BLOCK_INT)
	fclose(file)
	fMaxs[0] = size[5]-size[2];
	fMaxs[1] = size[4]-size[1];
	fMaxs[2] = size[3]-size[0];
	fMins[0] = -0.0;
	fMins[1] = -0.0;
	fMins[2] = -0.0;
}*/
